<!DOCTYPE html>
<html>
<head>
    <title>Leaflet Map with Labels</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.css" />
    <style>
        html, body {
            width: 100%;
            height: 100%;
            margin: 0;
            padding: 0;
            overflow: hidden; /* Prevent scrollbars */
        }
        #map {
            width: 100%;
            height: 100%;
        }
        .label {
            font-size: 12pt;
            font-weight: 400;
            color: black;
            text-align: center;
            white-space: nowrap;
            transform-origin: center;
            text-shadow:
                -1px -1px 0 white,
                1px -1px 0 white,
                -1px 1px 0 white,
                1px 1px 0 white;
        }
        .leaflet-tooltip {
            background: transparent; /* Make the background transparent */
            border: none; /* Remove the border */
            box-shadow: none; /* Remove the shadow */
            }

        .leaflet-tooltip::before,
        .leaflet-tooltip::after {
            border: none !important;
            }

        .custom-tooltip {
            font-size: 15px;
            font-weight: bold;
            color: black; /* Or any color you prefer for the text */
            padding: 1px; /* Add a 1px padding around the text */
            text-transform: uppercase; 
            text-shadow:
                -1px -1px 0 white,
                1px -1px 0 white,
                -1px 1px 0 white,
                1px 1px 0 white;

        }
    </style>
</head>
<body>
    <div id="map"></div>
    <script src="https://cdn.jsdelivr.net/npm/leaflet@1.9.3/dist/leaflet.js"></script>
    <script>
        var map = L.map('map').setView([45.5655427, 6.386334], 13);

        // L.tileLayer('http://mt0.google.com/vt/lyrs=p&hl=en&x={x}\u0026y={y}\u0026z={z}').addTo(map);
        L.tileLayer('https://tile.thunderforest.com/landscape/{z}/{x}/{y}.png?apikey=7c352c8ff1244dd8b732e349e0b0fe8d', {
            attribution: '&copy; <a href="http://www.thunderforest.com/">Thunderforest</a>, &copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
            apikey: '7c352c8ff1244dd8b732e349e0b0fe8d', // Replace with your actual API key
            maxZoom: 13
        }).addTo(map);
        var geojsonLayer;
        var labelTooltips = []; // Store tooltip instances
        var lineVisibilities = []; // Store pre-calculated line visibilities
        var minZoom = 9;
        var maxZoom = 14;
        var minLengthPx = 50;
        var buffer = 300;
        var pointLayers = []; // Global array to keep track of point layers

        // Haversine formula for more accurate distance in meters
        function haversine(lon1, lat1, lon2, lat2) {
            const R = 6371000; // Earth radius in meters
            const dLat = (lat2 - lat1) * Math.PI / 180;
            const dLon = (lon2 - lon1) * Math.PI / 180;
            const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                      Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                      Math.sin(dLon / 2) * Math.sin(dLon / 2);
            const c = 2 * Math.asin(Math.sqrt(a));
            return R * c;
        }

        // Function to determine if a line is long enough for labeling (in meters, then to pixels)
        function lineLengthInPixels(coords, zoom, lat_rad) {
            let totalLengthMeters = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                totalLengthMeters += haversine(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
            }

            // Calculate pixels per meter
            let resolution = Math.cos(lat_rad) * 2 * Math.PI * 6378137 / (256 * Math.pow(2, zoom));
            let pixelsPerMeter = 1 / resolution;

            // Convert total length to pixels
            let totalLengthPixels = totalLengthMeters * pixelsPerMeter;

            return totalLengthPixels;
        }

        function angleBetween(p1, p2) {
            // """Calculates the angle between two points in degrees using Haversine."""
            const lon1 = p1[0], lat1 = p1[1];
            const lon2 = p2[0], lat2 = p2[1];

            // Calculate distances in meters
            const y = haversine(lon1, lat2, lon1, lat1);  // North-south distance
            const x = haversine(lon2, lat1, lon1, lat1);  // East-west distance

            let angle = Math.atan2(y, x);
            if ((lon1>lon2 && lat1>lat2) || (lon1<lon2 && lat1<lat2)) angle=-angle
            return angle * 180 / Math.PI;
        }

        function preloadData(data) {
            data.features.forEach((feature) => {
                if (feature.geometry.type === 'LineString' && feature.properties.ELEV) {
                    const coords = feature.geometry.coordinates;
                    let cumDistances = [0];
                    for (let i = 1; i < coords.length; i++) {
                        const d = haversine(coords[i - 1][0], coords[i - 1][1], coords[i][0], coords[i][1]);
                        cumDistances.push(cumDistances[i - 1] + d);
                    }
                    // Cache the cumulative distances in the feature's properties for later fast lookup
                    feature.properties.cumDistances = cumDistances;
                }
            });
        }

        // Function: getPointAtDistance using binary search with cumDistances
        function getPointAtDistance(coords, targetDistance, cumDistances) {
            if (!cumDistances) {
                // Fallback to linear search if cumulative distances are not provided.
                let cum = 0;
                for (let i = 0; i < coords.length - 1; i++) {
                    let segDist = haversine(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                    if (cum + segDist >= targetDistance) {
                        let t = (targetDistance - cum) / segDist;
                        let lon = coords[i][0] + t * (coords[i+1][0] - coords[i][0]);
                        let lat = coords[i][1] + t * (coords[i+1][1] - coords[i][1]);
                        return [lon, lat];
                    }
                    cum += segDist;
                }
                return coords[coords.length - 1];
            } else {
                // Use binary search on the cumDistances array.
                let lo = 0, hi = cumDistances.length - 1;
                while (lo <= hi) {
                    let mid = Math.floor((lo + hi) / 2);
                    if (cumDistances[mid] < targetDistance) {
                        lo = mid + 1;
                    } else {
                        hi = mid - 1;
                    }
                }
                let i = Math.max(0, hi);
                if (i >= cumDistances.length - 1) return coords[coords.length - 1];
                let segmentDist = cumDistances[i+1] - cumDistances[i];
                let remain = targetDistance - cumDistances[i];
                let t = remain / segmentDist;
                let lon = coords[i][0] + t * (coords[i+1][0] - coords[i][0]);
                let lat = coords[i][1] + t * (coords[i+1][1] - coords[i][1]);
                return [lon, lat];
            }
        }

        // Helper to compute an angle (in degrees) at a given distance along the line.
        // In this case we simply use the angle of the segment where the distance falls.
        function getAngleAtDistance(coords, distance) {
            let cumDist = 0;
            for (let i = 0; i < coords.length - 1; i++) {
                let segDist = haversine(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                if (cumDist + segDist >= distance) {
                    return angleBetween(coords[i], coords[i+1]);
                }
                cumDist += segDist;
            }
            if (coords.length >= 2)
                return angleBetween(coords[coords.length - 2], coords[coords.length - 1]);
            return 0;
        }

        // Helper to add a label tooltip at a given point with the specified text and rotation angle.
        function addLabel(point, text, angle) {
            var label = document.createElement('div');
            label.className = 'label';
            label.textContent = text;
            label.style.transformOrigin = 'center';
            label.style.transform = `rotate(${angle}deg)`;

            var tooltip = L.tooltip({
                permanent: true,
                direction: 'center',
                className: 'leaflet-tooltip'
            })
            .setContent(label.outerHTML)
            .setLatLng([point[1], point[0]])
            .addTo(map);

            labelTooltips.push(tooltip);
        }

        // Function: updateLabels with first point's latitude and optimized point lookup.
        function updateLabels() {
            var currentZoom = map.getZoom();
            const bounds = map.getBounds();

            // Remove existing tooltips
            labelTooltips.forEach(function(tooltip) {
                tooltip.removeFrom(map);
            });
            labelTooltips = []; // Clear the array

            if (currentZoom > 10) {
                geojsonLayer.eachLayer(function (layer) {
                    if (layer.feature.geometry.type === 'LineString' && layer.feature.properties.ELEV) {
                        // Check if feature is within the current bounds
                        if (!bounds.intersects(layer.getBounds ? layer.getBounds() : L.geoJSON(layer.feature).getBounds())) {
                            return; // Skip offscreen features
                        }
                        var coords = layer.feature.geometry.coordinates;

                        // Use the latitude of the first point instead of the average.
                        var lat_rad = coords[0][1] * Math.PI / 180;

                        // Skip label rendering if the line is too short.
                        if (lineLengthInPixels(coords, currentZoom, lat_rad) < minLengthPx) {
                            return;
                        }

                        var elev = layer.feature.properties.ELEV;

                        // Calculate the total geodesic length (in meters) of the line.
                        var totalMeters = 0;
                        for (let i = 0; i < coords.length - 1; i++) {
                            totalMeters += haversine(coords[i][0], coords[i][1], coords[i+1][0], coords[i+1][1]);
                        }

                        // Compute the map resolution using the first point's latitude.
                        var resolution = Math.cos(coords[0][1] * Math.PI / 180) *
                                         2 * Math.PI * 6378137 / (256 * Math.pow(2, currentZoom));
                        // Convert the buffer (px) to meters.
                        var spacingMeters = buffer * resolution;

                        // If the line is too short for two labels, use just the midpoint.
                        if (totalMeters < 2 * spacingMeters) {
                            var midDistance = totalMeters / 2;
                            var point = getPointAtDistance(coords, midDistance, layer.feature.properties.cumDistances);
                            var angle = getAngleAtDistance(coords, midDistance);
                            addLabel(point, elev, angle);
                        } else {
                            // Place labels along the line with the specified buffer spacing.
                            for (var d = spacingMeters; d <= totalMeters - spacingMeters; d += spacingMeters) {
                                var point = getPointAtDistance(coords, d, layer.feature.properties.cumDistances);
                                var angle = getAngleAtDistance(coords, d);
                                addLabel(point, elev, angle);
                            }
                        }
                    }
                });
            }
        }

        // Define style function for GeoJSON features
        function styleFeature(feature) {
            if (feature.geometry.type === 'LineString') {
                return {
                    color: 'black',
                    weight: (map.getZoom() < 10) ? 1 : 2  // one pixel if zoom < 10, else two pixels
                };
            }
            return {};
        }

        // Load GeoJSON data and add it to the map
        fetch('nameToReplace')
            .then(response => response.json())
            .then(data => {
                window.data = data;
                preloadData(data);

                geojsonLayer = L.geoJSON(data, {
                    // Define how GeoJSON point features are rendered:
                    pointToLayer: function(feature, latlng) {
                        return L.circleMarker(latlng, {
                            radius: 10,
                            fillColor: "red",
                            color: "darkred",
                            weight: 2,
                            opacity: 1,
                            fillOpacity: 1
                        });
                    },
                    style: styleFeature,
                    onEachFeature: function(feature, layer) {
                        if (feature.geometry.type === 'Point') {
                            // Bind tooltip with the "name" property, 15px font size
                            layer.bindTooltip(
                                `<div class="custom-tooltip">${feature.properties.name}</div>`,
                                { direction: 'right', permanent: false, className: "no-arrow",
                                offset: [10, 0] }
                            );
                            pointLayers.push(layer);
                            // Open tooltip immediately if zoom is high enough
                            if (map.getZoom() >= 8) {
                                layer.openTooltip();
                            }
                        }
                        if (feature.geometry.type === 'LineString' && feature.properties.ELEV) {
                            feature.index = data.features.indexOf(feature);
                        }
                    }
                }).addTo(map);

                // Initial update for labels on lines
                updateLabels();

                // Function: debounce utility to throttle event handler execution
                function debounce(func, delay) {
                    let timeout;
                    return function(...args) {
                        clearTimeout(timeout);
                        timeout = setTimeout(() => {
                            func.apply(this, args);
                        }, delay);
                    }
                }

                // Wrap the zoomend event handler with debounce to improve performance.
                map.on('zoomend', debounce(function () {
                    geojsonLayer.setStyle(styleFeature);
                    updateLabels();
                    const currentZoom = map.getZoom();
                    pointLayers.forEach(function(layer) {
                        if (currentZoom >= 8) {
                            layer.openTooltip();
                        } else {
                            layer.closeTooltip();
                        }
                    });
                }, 200)); // 200ms debounce delay; adjust this value as needed.

                // Add moveend event handler to update labels when panning.
                map.on('moveend', debounce(function () {
                    updateLabels();
                    const currentZoom = map.getZoom();
                    pointLayers.forEach(function(layer) {
                        if (currentZoom >= 8) {
                            layer.openTooltip();
                        } else {
                            layer.closeTooltip();
                        }
                    });
                }, 200));
            });
    </script>
</body>
</html>
